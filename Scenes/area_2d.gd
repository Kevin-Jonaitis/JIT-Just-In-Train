extends Area2D

@onready var space_state = get_world_2d().direct_space_state

var segments = []
var drawableFunctionsToCallLater: Array[Callable] = []
# Map object id -> track object
# NOTE: We need to update this when deleting a track, otherwise this will be the last remaining 
# reference to a track object, and it will never be garbage collected
var intersecting_tracks : Dictionary = {}
# the segments we create when doing a recalculation. This will be materalized into
# actual segments once we solidfy the track
var polygons = []

# func _draw():
# 	for function in drawableFunctionsToCallLater:
# 		function.call()
# 	drawableFunctionsToCallLater.clear()


## Use this to check track collisions
# The way the collision checking works, is we generate rectangles based on the points in our track
# Then we compare those rectangles to the other tracks in the scene _directly_ using Physics2DServer
# Once we figure out what intersects, we update the intersecting track dict for both tracks.

# Then, when the user actually clicks to place a track, we solidfy those rectangle shapes by adding them
# to this track's Area2D, setting the collision maks so that only are dectable, but arn't detecting.

# The combo of physics server for checking collisions and baking the shapes into area2d for saving collision data
# seems to be the fastest solution for this
func check_track_collision(points: PackedVector2Array, width: int) -> bool:
	intersecting_tracks = {}
	polygons = calculate_rectangles(points, width)

	# for rectangle in polygons:
	# 	drawableFunctionsToCallLater.append(func(): draw_colored_polygon(rectangle, Color.RED))
	# queue_redraw()

	var query = PhysicsShapeQueryParameters2D.new()
	query.transform = Transform2D.IDENTITY
	query.collide_with_areas = true
	query.collide_with_bodies = false
	query.collision_mask = 1 
	var temp_shape = ConvexPolygonShape2D.new()
	query.set_shape(temp_shape)
		
	for rectangle_list in polygons:
		temp_shape.set_points(rectangle_list)
		var result = space_state.intersect_shape(query)
		for item in result:
			if (item.size() > 0 && !intersecting_tracks.has(item.collider_id)):
				intersecting_tracks[item.collider_id] = item.collider
	# print("COLLISION TIME: ", Time.get_ticks_usec() - start_time)
	return 0


# Generated by Chat-GPT
func calculate_rectangles(points: Array, width: float) -> Array:
	var temp_recs = []
	if points.size() < 2:
		push_error("Not enough points to calculate polygons. At least two points are required.")
		return []

	for i in range(points.size() - 1):
		var current_point = points[i]
		var next_point = points[i + 1]

		# Calculate the direction and distance
		var direction = (next_point - current_point).normalized()
		var distance = current_point.distance_to(next_point)

		# Calculate the rectangle's center
		var midpoint = (current_point + next_point) / 2.0

		# Create the rectangle points (rotated to align with the segment)
		var half_width = width / 2.0
		var half_length = distance / 2.0

		var perpendicular = Vector2(-direction.y, direction.x)  # Perpendicular to the direction
		var rect_points = PackedVector2Array([
			midpoint + perpendicular * half_width - direction * half_length,
			midpoint + perpendicular * half_width + direction * half_length,
			midpoint - perpendicular * half_width + direction * half_length,
			midpoint - perpendicular * half_width - direction * half_length
		])

		# Store the rectangle points as PackedVector2Array
		temp_recs.append(rect_points)

	return temp_recs

func compute_new_track(points: Array, width: int):
	var test_old_start = Time.get_ticks_usec()
	check_track_collision(points, width)
	# print("Total time collision check:", Time.get_ticks_usec() - test_old_start)

# Actually adds the shapes to the area
func solidfy_collision_area():
	set_collision_layer_value(1, false) #not on any layer
	set_collision_mask_value(1, true)  #not on any layer
	# var time_before = Time.get_ticks_usec()
	add_shapes_to_current_area()
	# print("Solidify Track: ", Time.get_ticks_usec() - time_before)
	
	for track in intersecting_tracks:
		var instance_id = get_instance_id()
		# Add this track to the other track list of intersecting tracks
		intersecting_tracks[track].intersecting_tracks[instance_id] = self

func add_shapes_to_current_area() -> void:
	collision_layer = 1
	collision_mask = 0

	var shape_owner = create_shape_owner(self)
	shape_owner_clear_shapes(shape_owner)

	# Add each rectangle as a ConvexPolygonShape2D to the shape owner
	for rectangle in polygons:
		var shape = ConvexPolygonShape2D.new()
		shape.points = rectangle

		# Add the shape to the shape owner
		shape_owner_add_shape(shape_owner, shape)
