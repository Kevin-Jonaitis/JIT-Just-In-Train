extends Node

# Nodes: node name (String) -> VirtualNode
var _nodes: Dictionary[String, VirtualNode] = {}

# Outgoing edges: from_node_name (String) -> Array of Edge
var outgoing_edges: Dictionary[String, Array] = {}

# Incoming edges: to_node_name (String) -> Array of from_node_name (String)
# ONLY USED TO HELP REMOVE NODES
var _incoming_edges: Dictionary[String, Array] = {}

# Turnaround loops: node_name (String) -> Edge (loop back to itself)
var turnaround_loops: Dictionary[String, Edge] = {}

# Turnaround loops by train: train name (String) -> Dictionary 
#   (inner Dictionary: node name (String) -> Edge)
var turnaround_loops_by_train: Dictionary[String, Dictionary] = {}

var update_turnaround_loops_dirty: bool = false

@onready var trains: Trains = Utils.get_node_by_ground_name("trains")
static var PROFILING_COUNT : int = 0


var string_to_int_map: Dictionary[String, int] = {}
var int_to_string_map: Dictionary[int, String] = {}
# Use cantor pairing to map two nodes to a unique int
# Contains both turnaround edges and regular edges
# Turnaround edges last only the length of time of the search for all stops for a train
var edges_to_cost_map: Dictionary[int, float] = {}


# Check if the astar names indicate a loopback edge
func check_if_loopback(node_a: int, node_b: int, train: Train) -> bool:
	var node_a_name: String = int_to_string_map[node_a]
	var node_b_name: String = int_to_string_map[node_b]
	var node_to_edge: Dictionary = turnaround_loops_by_train[train.name]
	if (node_to_edge.has(node_a_name)):
		var edge: Edge = node_to_edge[node_a_name]
		if (edge.to_node.name == node_b_name):
			return true
	return false

#TODO: This should probably be unique per usecase
func map_name_to_number(string: String) -> int:
	if string_to_int_map.has(string):
		return string_to_int_map[string]
	else:
		var new_id: int = string_to_int_map.size() #I assume this isn't slow because it's just pulling a simple int
		int_to_string_map[new_id] = string
		string_to_int_map[string] = new_id
		return new_id

# Generated by chat-GPT
# -------------------------------------------------------------------
# Node Management
# -------------------------------------------------------------------

func cantor_pair(a: int, b: int) -> int:
	var s: int = a + b
	return int((s * (s + 1)) / 2.0) + b

func add_edge_to_cost_map(from_node: VirtualNode, to_node: VirtualNode, cost: float) -> void:
	var from_id: int = from_node.identifier
	var to_id: int = to_node.identifier
	var cantor_id: int = cantor_pair(from_id, to_id)
	edges_to_cost_map[cantor_id] = cost

func remove_edge_from_cost_map(from_node: VirtualNode, to_node: VirtualNode) -> void:
	var from_id: int = from_node.identifier
	var to_id: int = to_node.identifier
	var cantor_id: int = cantor_pair(from_id, to_id)
	edges_to_cost_map.erase(cantor_id)

func get_cost(a: int, b: int) -> float:
	# Inline the math to make it as fast as possible
	return edges_to_cost_map[int(((a + b) * ((a + b) + 1)) / 2.0) + b]	

func map_identifier_to_node(number: int) -> VirtualNode:
	return _nodes[int_to_string_map[number]]

func get_turnaround_loops_for_train(train: Train) -> Dictionary:
	var train_key: String = train.name
	if turnaround_loops_by_train.has(train_key):
		return turnaround_loops_by_train[train_key] as Dictionary
	else:
		return {}
func get_turnaround_loop_for_train_at_node(train: Train, node: VirtualNode) -> Edge:
	var train_key: String = train.name
	assert(turnaround_loops_by_train.has(train_key), "Train must be provided")
	var loops: Dictionary = turnaround_loops_by_train[train_key] as Dictionary
	assert(loops.has(node.name), "This must exist because we expect it to")
	return loops[node.name] as Edge


# Used for performance printing
func get_num_of_edges() -> int:
	var count: int = 0
	for node_name: String in outgoing_edges.keys():
		count += outgoing_edges[node_name].size()
	return count

func get_connected_edges(node: VirtualNode, train: Train, get_turnarounds: bool = true) -> Array[Edge]:
	assert(train, "Train must be provided")
	var connected_edges: Array[Edge] = []
	if outgoing_edges.has(node.name):
		# Get the actual array (no assign(), so changes affect the stored array)
		connected_edges.assign(outgoing_edges[node.name] as Array[Edge])
	
	# Lookup turnaround loops for this train (keyed by train.name)
	if (get_turnarounds):
		var train_key: String = train.name
		if turnaround_loops_by_train.has(train_key):
			var loops: Dictionary = turnaround_loops_by_train[train_key] as Dictionary
			if loops.has(node.name):
				connected_edges.append(loops[node.name] as Edge)
	return connected_edges
	
func add_node(node: VirtualNode) -> void:
	_nodes[node.name] = node
	# exit_nodes = get_all_exit_nodes()
	verify_edges()
	Pathfinder.A_STAR.add_point(node.identifier, node.get_vector_pos())


func remove_node(node: VirtualNode) -> void:
	var node_name: String = node.name

	# Remove outgoing edges from this node
	if outgoing_edges.has(node_name):
		# Iterate backwards to avoid index issues
		for i: int in range(outgoing_edges[node_name].size() - 1, -1, -1):
			var edge: Edge = outgoing_edges[node_name][i]
			remove_edge(node, edge.to_node)

	# Remove all edges that point to this node
	if _incoming_edges.has(node_name):
		# Iterate backwards to avoid index issues
		for i: int in range(_incoming_edges[node_name].size() - 1, -1, -1):
			var from_name: String = _incoming_edges[node_name][i]
			remove_edge(_nodes[from_name], node)

	# Remove any turnaround loop for this node from every train's dictionary
	for train_key: String in turnaround_loops_by_train.keys():
		var loops: Dictionary = turnaround_loops_by_train[train_key] as Dictionary
		if loops.has(node_name):
			loops.erase(node_name)

	_nodes.erase(node_name)
	Pathfinder.A_STAR.remove_point(node.identifier)
	# exit_nodes = get_all_exit_nodes()
	verify_edges()


# -------------------------------------------------------------------
# Edge Management
# -------------------------------------------------------------------
func add_edge(from_node: VirtualNode, to_node: VirtualNode, cost: float) -> void:
	var edge: Edge = Edge.new(to_node, cost)
	edge.intermediate_nodes = []  # For non-turnaround edges, remains empty

	if not outgoing_edges.has(from_node.name):
		outgoing_edges[from_node.name] = []
	outgoing_edges[from_node.name].append(edge)

	if not _incoming_edges.has(to_node.name):
		_incoming_edges[to_node.name] = []
	_incoming_edges[to_node.name].append(from_node.name)

	Pathfinder.A_STAR.connect_points(from_node.identifier, to_node.identifier, false)
	add_edge_to_cost_map(from_node, to_node, cost)

	verify_edges()


func add_reverse_connection_to_astar(from_node: VirtualNode, to_node: VirtualNode, cost: float) -> void:
	add_edge_to_cost_map(from_node, to_node, cost)
	Pathfinder.A_STAR.connect_points(from_node.identifier, to_node.identifier, false)

func remove_reverse_connection_from_astar(from_node: VirtualNode, to_node: VirtualNode) -> void:
	Pathfinder.A_STAR.disconnect_points(from_node.identifier, to_node.identifier, false)
	remove_edge_from_cost_map(from_node, to_node)

# NOT TESTED, HOPEFULLY THIS WORKS
func remove_edge(from_node: VirtualNode, to_node: VirtualNode) -> void:
	var from_name: String = from_node.name
	var to_name: String = to_node.name

	assert(outgoing_edges.has(from_name), "Outgoing edge must exist")
	assert(_incoming_edges.has(to_name), "Reverse incoming edge must also exist")

	var edges_array: Array = outgoing_edges[from_name]
	var remove_count: int = 0
	for i: int in range(edges_array.size() - 1, -1, -1):
		if edges_array[i].to_node.name == to_name:
			assert(remove_count == 0, "How are we removing twice?")
			remove_count = remove_count + 1
			if (edges_array.size() == 1):
				outgoing_edges.erase(from_name)
			else:
				edges_array.remove_at(i)

	if (_incoming_edges[to_name].size() == 1):
		_incoming_edges.erase(to_name)
	else:
		_incoming_edges[to_name].erase(from_name)

	Pathfinder.A_STAR.disconnect_points(from_node.identifier, to_node.identifier, false)
	remove_edge_from_cost_map(from_node, to_node)

	verify_edges()

# -------------------------------------------------------------------
# Turnaround Loop Management (Per-Train)
# -------------------------------------------------------------------
# New public function that updates turnaround loops for a given train.
func update_turnaround_loops_for_train(train: Train) -> void:
	var junction_nodes: Array[JunctionNode] = get_all_exit_nodes()
	for junction_node: JunctionNode in junction_nodes:
		var node_name: String = junction_node.name
		if turnaround_loops.has(node_name):
			var loop_edge: Edge = turnaround_loops[node_name]
			if not _is_loop_valid(node_name, loop_edge):
				_calculate_and_set_turnaround_loop(junction_node, train)
		else:
			# Otherwise, try to calculate one.
			_calculate_and_set_turnaround_loop(junction_node, train)
			

# TODO: This might not actually be much better than just recalcuating all loops every time.
func _is_loop_valid(start_node_name: String, loop_edge: Edge) -> bool:
	if loop_edge == null:
		return false
	# Simulate walking the chain for this specific train.
	var current_name: String = start_node_name
	var chain: Array[VirtualNode] = loop_edge.intermediate_nodes  # Expected to be Array of VirtualNode

	for next_node: VirtualNode in chain:
		if (next_node is StopNode): # Don't find connections for stop _nodes because they're dynamically created
			continue
		if not outgoing_edges.has(current_name):
			return false
		var found_edge: Edge = _find_edge_to(outgoing_edges[current_name], next_node.name)
		if found_edge == null:
			return false
		current_name = next_node.name
	
	# Then from the last intermediate node back to the start node
	if not outgoing_edges.has(current_name):
		return false
	var closing_edge: Edge = _find_edge_to(outgoing_edges[current_name], start_node_name)
	if closing_edge == null:
		return false

	# Optionally, add train-specific validations (e.g. ensure the path length is sufficient for the train)
	# For example:
	# if (calculate_total_cost(loop_edge) < train.length):
	#     return false

	return true


func _calculate_and_set_turnaround_loop(node: JunctionNode, train: Train) -> void:
	assert(node.is_exit_node(), "Turnaround loops are only valid for exit nodes")
	var reverse_edge: Edge = node.get_reverse_edge(train)
	var train_key: String = train.name
	# If no turnaround loops exist for this train yet, create a new dictionary.
	if not turnaround_loops_by_train.has(train_key):
		turnaround_loops_by_train[train_key] = {}
	# Retrieve the inner dictionary (mapping node name -> Edge)
	var loops: Dictionary = turnaround_loops_by_train[train_key] as Dictionary
	# Add or update the turnaround loop for the given junction.
	if (reverse_edge != null):
		loops[node.name] = reverse_edge
	else:
		loops.erase(node.name)


func get_all_exit_nodes() -> Array[JunctionNode]:
	var exit_nodes: Array[JunctionNode] = []
	for node_name: String in _nodes.keys():
		var node: VirtualNode = _nodes[node_name]
		if node is JunctionNode && (node as JunctionNode).is_exit_node():
			exit_nodes.append(node as JunctionNode)
	
	return exit_nodes

func _find_edge_to(edges_array: Array, target_name: String) -> Edge:
	for e: Edge in edges_array:
		if e.to_node and e.to_node.name == target_name:
			return e
	return null



func verify_edges() -> void:
	pass
	# # Verify the values in the outgoing arrays match the incoming arrays
	# for node_name: String in outgoing_edges.keys():
	# 	var edges_array: Array = outgoing_edges[node_name]
	# 	assert(_nodes.has(node_name), "Outgoing edge says it has a node but it's not in nodes!")

	# 	# Use a dictionary to track which 'to' nodes we've seen for this 'from' node.
	# 	var seen_targets: Dictionary = {}


	# 	for edge: Edge in edges_array:
	# 		var to_name: String = edge.to_node.name

	# 		# Verify that we haven't already seen an edge going to the same target.
	# 		assert(not seen_targets.has(to_name), "Duplicate edge found: " + node_name + " -> " + to_name)
	# 		seen_targets[to_name] = true

	# 		assert(_nodes.has(edge.to_node.name), "Outgoing edge says it's going to a node but it's not in the list of _nodes!")
	# 		assert(_incoming_edges.has(edge.to_node.name), "Outgoing edge has no incoming edge")
	# 		assert(_incoming_edges[edge.to_node.name].find(node_name) != -1, "Outgoing edge has no incoming edge") 
	

# -------------------------------------------------------------------
# Debug
# -------------------------------------------------------------------
func print_graph() -> void:
	print("")
	# Build a dictionary mapping node_name -> a more readable description.
	var node_debug_map: Dictionary[String, String] = {}
	for node_name: String in _nodes.keys():
		var node_obj : VirtualNode = _nodes[node_name]
		# For now, just store the node's name (or any short identifier).
		# If your VirtualNode has a custom method like get_debug_string(), you could call that here.
		node_debug_map[node_name] = "VirtualNode(name=" + node_obj.name + ")"

	# Now print the debug dictionary instead of the raw '_nodes' dictionary.
	# print("Nodes: ", node_debug_map)
	print("Nodes:")
	for node_name: String in node_debug_map.keys():
		# Print the node's name and any other relevant info
		print("  ", node_name)


	# Print outgoing edges as before
	print("Outgoing Edges:")
	for node_name: String in outgoing_edges.keys():
		var edges_array: Array[Edge]
		edges_array.assign(outgoing_edges[node_name] as Array[Edge])
		for edge: Edge in edges_array:
			print(
				"  ", node_name, 
				" -> ", edge.to_node.name, 
				", cost=", edge.cost
			)

	# Print incoming edges as before
	print("Incoming Edges: ")
	for incoming_edge: String in _incoming_edges.keys():
		var from_list: Array[String] 
		from_list.assign(_incoming_edges[incoming_edge] as Array[String])
		print("  ", incoming_edge, " -> ", from_list)
	
	print("Turnaround Loops By Train:")
	for train_key: String in turnaround_loops_by_train.keys():
		var loops: Dictionary = turnaround_loops_by_train[train_key]
		print("  Train: ", train_key)
		for node_name: String in loops.keys():
			var loop_edge: Edge = loops[node_name]
			var node_list: String = ""
			for node: VirtualNode in loop_edge.intermediate_nodes:
				node_list += node.name + ", "
			print("    ", node_name, " -> Edge(to=", loop_edge.to_node.name, ", list=", node_list, " cost=", str(loop_edge.cost), ")")


func debug_verify_astar_vs_graph() -> void:
	print("----- DEBUG: Verifying AStar Graph vs. Internal Graph -----")

	# Verify that every node in our internal graph exists in AStar.
	var astar_count: int = Pathfinder.A_STAR.get_point_count()
	var internal_count: int = _nodes.size()
	print("AStar node count: ", astar_count, " | Internal node count: ", internal_count)
	if astar_count != internal_count:
		assert(false, "WARNING: Node count mismatch between AStar and internal graph!")

	# Verify each node's existence and position.
	for node_name: String in _nodes.keys():
		var node: VirtualNode = _nodes[node_name]
		if not Pathfinder.A_STAR.has_point(node.identifier):
			print("ERROR: AStar is missing node: ", node_name, " (ID: ", node.identifier, ")")
		else:
			var pos_astar: Vector2 = Pathfinder.A_STAR.get_point_position(node.identifier)
			var pos_internal: Vector2 = node.get_vector_pos()
			if pos_astar.distance_to(pos_internal) > 0.001:
				print("WARNING: Position mismatch for node '", node_name, 
						"'. AStar pos: ", pos_astar, " | Internal pos: ", pos_internal)

	
	
	# Verify outgoing edges.
	print("----- Outgoing Edges -----")
	for from_name: String in outgoing_edges.keys():
		if not _nodes.has(from_name):
			assert(false, "ERROR: Internal nodes missing source node: " + from_name)
			continue
		var from_node: VirtualNode = _nodes[from_name]
		var edges_array: Array = outgoing_edges[from_name]
		for edge: Edge in edges_array:
			var to_node: VirtualNode = edge.to_node
			if not Pathfinder.A_STAR.has_point(to_node.identifier):
				assert(false, "ERROR: AStar missing target node: " + to_node.name)
				continue
			# Verify that AStar reports a connection exists.
			if not Pathfinder.A_STAR.are_points_connected(from_node.identifier, to_node.identifier, false):
				assert(false, "ERROR: AStar does not have a connection for edge " +  from_name + " -> " + to_node.name)
			else:
				# Get the cost for the edge using our own cost mapping.
				var astar_cost: float = get_cost(from_node.identifier, to_node.identifier)
				var internal_cost: float = edge.cost
				if abs(astar_cost - internal_cost) > 0.001:
					assert(false, "ERROR: Cost mismatch for edge " + from_name + " -> " + to_node.name 
					+ ". AStar cost: " + str(astar_cost) + " | Internal cost: " + str(internal_cost))
				else:
					print("Edge ", from_name, " -> ", to_node.name, " verified (cost: ", astar_cost, ")")

	print("----- DEBUG: Verification complete -----")

func debug_print_astar_network(start_position: Stop.TrainPosition, end: StopNode) -> void:
	print("----- Full AStar2D Network -----")
	print("START POISITON forward: " + start_position.front_of_train.name)
	print("START POISITON backward: " + start_position.back_of_train.name)
	print("END POSITION: " + end.name)

	# Get all point IDs in the AStar2D graph.
	var point_ids: PackedInt64Array = Pathfinder.A_STAR.get_point_ids()
	print("Total points in AStar: ", point_ids.size())

	# First, print all points.
	print("----- Points -----")
	for id: int in point_ids:
		var node_name: String = ""
		if int_to_string_map.has(id):
			node_name = int_to_string_map[id]
		else:
			assert(false, "ERROR: Unknown node ID in AStar graph: " + str(id))
		var pos: Vector2 = Pathfinder.A_STAR.get_point_position(id)
		print("Point ID: ", id, " (", node_name, ") at position: ", pos)

	# Print connections in one line per connection.
	print("----- Connections -----")
	for id: int in point_ids:
		var source_name: String = ""
		if int_to_string_map.has(id):
			source_name = int_to_string_map[id]
		else:
			assert(false, "ERROR: Unknown node ID in AStar graph: " + str(id))
		
		var connections: PackedInt64Array = Pathfinder.A_STAR.get_point_connections(id)
		for conn_id: int in connections:
			var target_name: String = ""
			if int_to_string_map.has(conn_id):
				target_name = int_to_string_map[conn_id]
			else:
				assert(false, "ERROR: Unknown connection ID in AStar graph: " + str(conn_id))
			
			# Retrieve the cost using your cost mapping.
			var cost: float = get_cost(id, conn_id)
			print(source_name, " (", id, ") -> ", target_name, " (", conn_id, ") cost: ", cost)
	print("----- End of AStar2D Network -----")
