extends RefCounted

class_name  Schedule

# path between each pair of stops
var paths: Array[Path]
var is_loop: bool
var stops: Array[StopNode]:
	get:
		var stops_temp : Array[StopNode] = []
		for path : Path in paths:
			stops_temp.append(path.nodes[0])
		# Append last stop of last node
		stops_temp.append(paths[-1].nodes[-1])
		return stops_temp
	set(value):
		assert(false, "Cannot set stops")
		
func _init(stops_path_: Array[Path], is_loop_: bool) -> void:
	self.paths = stops_path_
	self.is_loop = is_loop_
	if (is_loop_):
		assert(VirtualNode.are_nodes_are_at_same_position(stops[0], stops[-1]), "A loop should have the same start and end stops")
		assert(stops_path_.size() > 1, "A loop should have at least 2 stops")

func get_path(stop_index: int) -> Path:
	return paths[stop_index]


# Generated by chat gpt
func debug_print_schedule() -> void:
	print("=== Schedule Debug Info ===")
	print("Is loop: ", self.is_loop)

	# Print all stops along the schedule
	var stops_arr: Array = self.stops
	print("Stops along schedule:")
	for stop: VirtualNode in stops_arr:
		# Assumes StopNode has a 'name', a 'track' with a uuid, and a get_track_position() method.
		print("  Stop: ", stop.name, " | Track: ", stop.track.uuid, " | Position: ", stop.get_track_position())

	# For each path in the schedule, print its start and end stops.
	print("Paths:")
	for i: int in range(self.paths.size()):
		var p: Path = self.paths[i]
		if p.nodes.size() < 1:
			print("  Path ", i, " is empty.")
			continue

		var start_node: VirtualNode = p.nodes[0]
		var end_node: VirtualNode = p.nodes[p.nodes.size() - 1]
		print("  Path ", i, ":")
		print("    From: ", start_node.name, " (Track: ", start_node.track.uuid, ", Pos: ", start_node.get_track_position(), ")")
		print("    To:   ", end_node.name, " (Track: ", end_node.track.uuid, ", Pos: ", end_node.get_track_position(), ")")
		print("    Virtual nodes: ")
		for node: VirtualNode in p.nodes:
			print("      - Node: ", node.name)
		# # Also print the track segments for this path
		# print("    Track Segments:")
		# for seg: Path.TrackSegment in p.track_segments:
		# 	print("      - Track: ", seg.track.uuid,
		# 			" | Start pos: ", seg.start_track_pos,
		# 			" | End pos: ", seg.end_track_pos,
		# 			" | Length: ", seg.get_length())
