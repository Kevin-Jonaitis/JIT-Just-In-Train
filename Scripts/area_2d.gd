extends Area2D

class_name Area

var uuid: String = Utils.generate_unique_id()
@onready var space_state: PhysicsDirectSpaceState2D = get_world_2d().direct_space_state

var drawableFunctionsToCallLater: Array[Callable] = []

func _draw() -> void:
	pass
	# for function in drawableFunctionsToCallLater:
	# 	function.call()
	drawableFunctionsToCallLater.clear()

# Actually adds the shapes to the area
func solidify_collision_area() -> void:
	# var time_before = Time.get_ticks_usec()
	add_shapes_to_current_area()
	# print("Solidify Track: ", Time.get_ticks_usec() - time_before)

func add_shapes_to_current_area() -> void:
	var track: Track = get_parent()
	var polygons: Array[PackedVector2Array] = calculate_rectangles(track.dubins_path.shortest_path.get_points(), \
	track.track_visual_component.backing.width)
	collision_layer = 1
	collision_mask = 0

	var shape_owner: int = create_shape_owner(self)
	shape_owner_clear_shapes(shape_owner)

	# Add each rectangle as a ConvexPolygonShape2D to the shape owner
	for rectangle: PackedVector2Array in polygons:
		var shape: ConvexPolygonShape2D = ConvexPolygonShape2D.new()
		shape.points = rectangle

		# Add the shape to the shape owner
		shape_owner_add_shape(shape_owner, shape)

# Generated by Chat-GPT
func calculate_rectangles(points: Array[Vector2], width: float) -> Array[PackedVector2Array]:
	var temp_recs: Array[PackedVector2Array] = []
	if points.size() < 2:
		assert(false, "Not enough points to calculate polygons. At least two points are required.")
		return []

	for i: int in range(points.size()):
		# ---------------------------------------------------------------------
		# STEP 1: Determine the direction vector and distance
		#         based on whether we're at first, last, or interior point.
		# ---------------------------------------------------------------------
		var direction: Vector2 = Vector2()
		var distance: float = 0.0

		if i == 0:
			# First point: use the segment from point[0] to point[1],
			# but only extend forward.
			if points.size() == 1:
				# Edge case (shouldn't happen due to check above),
				# but we handle it just in case.
				continue
			direction = (points[i + 1] - points[i]).normalized()
			distance = points[i].distance_to(points[i + 1])

		elif i == points.size() - 1:
			# Last point: use the segment from point[n-2] to point[n-1],
			# but only extend backward.
			direction = (points[i] - points[i - 1]).normalized()
			distance = points[i - 1].distance_to(points[i])

		else:
			# Interior point: use the segment from (i-1) to (i+1).
			direction = (points[i + 1] - points[i - 1]).normalized()
			distance = points[i - 1].distance_to(points[i + 1])

		# ---------------------------------------------------------------------
		# STEP 2: Center = this point, half-length = distance / 2 (or possibly
		#         just distance if it's the first or last point).
		# ---------------------------------------------------------------------
		var center: Vector2 = points[i]
		var half_width: float = width / 2.0
		var half_length: float = distance / 2.0

		# ---------------------------------------------------------------------
		# STEP 3: Compute perpendicular vector
		# ---------------------------------------------------------------------
		var perpendicular: Vector2 = Vector2(-direction.y, direction.x)

		# ---------------------------------------------------------------------
		# STEP 4: Build the rectangle corners
		# ---------------------------------------------------------------------
		var rect_points: PackedVector2Array = PackedVector2Array()

		if i == 0:
			# First point: do NOT extend behind the point
			# So we only go forward by half_length in 'direction'.
			rect_points.append(center + perpendicular * half_width)                           # top-left
			rect_points.append(center + perpendicular * half_width + direction * half_length) # top-right
			rect_points.append(center - perpendicular * half_width + direction * half_length) # bottom-right
			rect_points.append(center - perpendicular * half_width)                           # bottom-left

		elif i == points.size() - 1:
			# Last point: do NOT extend beyond the last point
			# So we only go backward by half_length in '-direction'.
			rect_points.append(center + perpendicular * half_width - direction * half_length) # top-left
			rect_points.append(center + perpendicular * half_width)                           # top-right
			rect_points.append(center - perpendicular * half_width)                           # bottom-right
			rect_points.append(center - perpendicular * half_width - direction * half_length) # bottom-left

		else:
			# Interior point: extend half_length in both directions
			rect_points.append(center + perpendicular * half_width - direction * half_length) # top-left
			rect_points.append(center + perpendicular * half_width + direction * half_length) # top-right
			rect_points.append(center - perpendicular * half_width + direction * half_length) # bottom-right
			rect_points.append(center - perpendicular * half_width - direction * half_length) # bottom-left

		temp_recs.append(rect_points)

	return temp_recs
