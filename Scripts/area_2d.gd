extends Area2D

@onready var space_state = get_world_2d().direct_space_state

var segments = []
var drawableFunctionsToCallLater: Array[Callable] = []
# Map object id -> track object
# NOTE: We need to update this when deleting a track, otherwise this will be the last remaining 
# reference to a track object, and it will never be garbage collected
var intersecting_tracks : Dictionary = {}
# the segments we create when doing a recalculation. This will be materalized into
# actual segments once we solidfy the track
var polygons = []

func _draw():
	pass
	# for function in drawableFunctionsToCallLater:
	# 	function.call()
	# drawableFunctionsToCallLater.clear()


## Use this to check track collisions
# The way the collision checking works, is we generate rectangles based on the points in our track
# Then we compare those rectangles to the other tracks in the scene _directly_ using Physics2DServer
# Once we figure out what intersects, we update the intersecting track dict for both tracks.

# Then, when the user actually clicks to place a track, we solidfy those rectangle shapes by adding them
# to this track's Area2D, setting the collision maks so that only are dectable, but arn't detecting.

# The combo of physics server for checking collisions and baking the shapes into area2d for saving collision data
# seems to be the fastest solution for this
func check_track_collision(points: PackedVector2Array, width: int) -> bool:
	intersecting_tracks = {}
	polygons = calculate_rectangles(points, width)

	for rectangle in polygons:
		drawableFunctionsToCallLater.append(func(): draw_colored_polygon(rectangle, Color.RED))
	queue_redraw()

	var query = PhysicsShapeQueryParameters2D.new()
	query.transform = Transform2D.IDENTITY
	query.collide_with_areas = true
	query.collide_with_bodies = false
	query.collision_mask = 1 
	var temp_shape = ConvexPolygonShape2D.new()
	query.set_shape(temp_shape)
		
	for rectangle_list in polygons:
		temp_shape.set_points(rectangle_list)
		var result = space_state.intersect_shape(query)
		for item in result:
			if (item.size() > 0 && !intersecting_tracks.has(item.collider_id)):
				intersecting_tracks[item.collider_id] = item.collider
	# print("COLLISION TIME: ", Time.get_ticks_usec() - start_time)
	return 0


func compute_new_track(points: Array, width: int):
	var test_old_start = Time.get_ticks_usec()
	check_track_collision(points, width)
	# print("Total time collision check:", Time.get_ticks_usec() - test_old_start)

# Actually adds the shapes to the area
func solidfy_collision_area():
	set_collision_layer_value(1, false) #not on any layer
	set_collision_mask_value(1, true)  #not on any layer
	# var time_before = Time.get_ticks_usec()
	add_shapes_to_current_area()
	# print("Solidify Track: ", Time.get_ticks_usec() - time_before)
	
	for track in intersecting_tracks:
		var instance_id = get_instance_id()
		# Add this track to the other track list of intersecting tracks
		intersecting_tracks[track].intersecting_tracks[instance_id] = self

func add_shapes_to_current_area() -> void:
	collision_layer = 1
	collision_mask = 0

	var shape_owner = create_shape_owner(self)
	shape_owner_clear_shapes(shape_owner)

	# Add each rectangle as a ConvexPolygonShape2D to the shape owner
	for rectangle in polygons:
		var shape = ConvexPolygonShape2D.new()
		shape.points = rectangle

		# Add the shape to the shape owner
		shape_owner_add_shape(shape_owner, shape)

# Generated by Chat-GPT
func calculate_rectangles(points: Array, width: float) -> Array:
	var temp_recs = []
	if points.size() < 2:
		push_error("Not enough points to calculate polygons. At least two points are required.")
		return []

	for i in range(points.size()):
		# ---------------------------------------------------------------------
		# STEP 1: Determine the direction vector and distance
		#         based on whether we're at first, last, or interior point.
		# ---------------------------------------------------------------------
		var direction = Vector2()
		var distance = 0.0

		if i == 0:
			# First point: use the segment from point[0] to point[1],
			# but only extend forward.
			if points.size() == 1:
				# Edge case (shouldn't happen due to check above),
				# but we handle it just in case.
				continue
			direction = (points[i + 1] - points[i]).normalized()
			distance = points[i].distance_to(points[i + 1])

		elif i == points.size() - 1:
			# Last point: use the segment from point[n-2] to point[n-1],
			# but only extend backward.
			direction = (points[i] - points[i - 1]).normalized()
			distance = points[i - 1].distance_to(points[i])

		else:
			# Interior point: use the segment from (i-1) to (i+1).
			direction = (points[i + 1] - points[i - 1]).normalized()
			distance = points[i - 1].distance_to(points[i + 1])

		# ---------------------------------------------------------------------
		# STEP 2: Center = this point, half-length = distance / 2 (or possibly
		#         just distance if it's the first or last point).
		# ---------------------------------------------------------------------
		var center = points[i]
		var half_width = width / 2.0
		var half_length = distance / 2.0

		# ---------------------------------------------------------------------
		# STEP 3: Compute perpendicular vector
		# ---------------------------------------------------------------------
		var perpendicular = Vector2(-direction.y, direction.x)

		# ---------------------------------------------------------------------
		# STEP 4: Build the rectangle corners
		# ---------------------------------------------------------------------
		var rect_points = PackedVector2Array()

		if i == 0:
			# First point: do NOT extend behind the point
			# So we only go forward by half_length in 'direction'.
			rect_points.append(center + perpendicular * half_width)                           # top-left
			rect_points.append(center + perpendicular * half_width + direction * half_length) # top-right
			rect_points.append(center - perpendicular * half_width + direction * half_length) # bottom-right
			rect_points.append(center - perpendicular * half_width)                           # bottom-left

		elif i == points.size() - 1:
			# Last point: do NOT extend beyond the last point
			# So we only go backward by half_length in '-direction'.
			rect_points.append(center + perpendicular * half_width - direction * half_length) # top-left
			rect_points.append(center + perpendicular * half_width)                           # top-right
			rect_points.append(center - perpendicular * half_width)                           # bottom-right
			rect_points.append(center - perpendicular * half_width - direction * half_length) # bottom-left

		else:
			# Interior point: extend half_length in both directions
			rect_points.append(center + perpendicular * half_width - direction * half_length) # top-left
			rect_points.append(center + perpendicular * half_width + direction * half_length) # top-right
			rect_points.append(center - perpendicular * half_width + direction * half_length) # bottom-right
			rect_points.append(center - perpendicular * half_width - direction * half_length) # bottom-left

		temp_recs.append(rect_points)

	return temp_recs
