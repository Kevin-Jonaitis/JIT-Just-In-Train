extends Area3D

class_name AreaCollision

var uuid: String = Utils.generate_unique_id()
@onready var space_state: PhysicsDirectSpaceState3D = get_world_3d().direct_space_state

var drawableFunctionsToCallLater: Array[Callable] = []

func _draw() -> void:
	pass
	# for function in drawableFunctionsToCallLater:
	# 	function.call()
	drawableFunctionsToCallLater.clear()

# Actually adds the shapes to the area
func solidify_collision_area() -> void:
	# var time_before = Time.get_ticks_usec()
	add_shapes_to_current_area_3d()
	pass
	# print("Solidify Track: ", Time.get_ticks_usec() - time_before)

# func add_shapes_to_current_area() -> void:
# 	var track: Track3D = get_parent()
# 	var polygons: Array[PackedVector2Array] = calculate_rectangles(track.dubins_path.shortest_path.get_points(), \
# 	track.track_visual_component.width)
# 	collision_layer = 1
# 	collision_mask = 0

# 	var shape_owner: int = create_shape_owner(self)
# 	shape_owner_clear_shapes(shape_owner)

# 	# Add each rectangle as a ConvexPolygonShape2D to the shape owner
# 	for rectangle: PackedVector2Array in polygons:
# 		var shape: ConvexPolygonShape2D = ConvexPolygonShape2D.new()
# 		shape.points = rectangle

# 		# Add the shape to the shape owner
# 		shape_owner_add_shape(shape_owner, shape)

func add_shapes_to_current_area_3d() -> void:
	# Assume the parent is a Track3D that holds path and visual info.
	var track: Track3D = get_parent() as Track3D
	var polygons: Array[PackedVector2Array] = calculate_rectangles(
		track.dubins_path.shortest_path.get_points(), 
		track.track_visual_component.width
	)
	
	# Set up collision layers/masks as needed.
	collision_layer = 1
	collision_mask = 0

	var rail_height: float = 1.0

	# For each rectangle, create its own shape owner.
	for rectangle: PackedVector2Array in polygons:
		# Expect exactly 4 points per rectangle.
		if rectangle.size() != 4:
			continue

		# Compute the 2D center (on the XZ plane).
		var center2d: Vector2 = (rectangle[0] + rectangle[1] + rectangle[2] + rectangle[3]) / 4.0

		# Compute full width and full length.
		var full_width: float = rectangle[0].distance_to(rectangle[3])
		var full_length: float = rectangle[0].distance_to(rectangle[1])
		# # For transform calculation:
		# var half_width: float = full_width / 2.0
		# var half_length: float = full_length / 2.0

		# Determine the 2D direction (from point0 to point1).
		var direction: Vector2 = (rectangle[1] - rectangle[0]).normalized()
		# Compute a Y rotation so the box's Z-axis (depth) aligns with the track.
		var rotation_y: float = direction.angle() - PI / 2.0

		# Create a new BoxShape3D and set its size (full dimensions).
		var box_shape: BoxShape3D = BoxShape3D.new()
		box_shape.size = Vector3(full_width, rail_height, full_length)

		# Create a separate shape owner for this rectangle.
		var shape_owner: int = create_shape_owner(self)
		shape_owner_add_shape(shape_owner, box_shape)

		# Build a Transform3D for the shape.
		# Map the 2D center (x,z) to 3D (x, rail_height/2, z) so the box sits on the ground.
		var shape_transform: Transform3D = Transform3D(
			Basis(Vector3.UP, rotation_y),
			Vector3(center2d.x, rail_height / 2.0, center2d.y)
		)

		# Set the transform for this shape owner (applies to all shapes in itâ€”here just one).
		shape_owner_set_transform(shape_owner, shape_transform)


func calculate_rectangles(points: Array[Vector2], width: float) -> Array[PackedVector2Array]:
# Generated by Chat-GPT
	var temp_recs: Array[PackedVector2Array] = []
	if points.size() < 2:
		assert(false, "Not enough points to calculate polygons. At least two points are required.")
		return []

	for i: int in range(points.size()):
		# ---------------------------------------------------------------------
		# STEP 1: Determine the direction vector and distance
		#         based on whether we're at first, last, or interior point.
		# ---------------------------------------------------------------------
		var direction: Vector2 = Vector2()
		var distance: float = 0.0

		if i == 0:
			# First point: use the segment from point[0] to point[1],
			# but only extend forward.
			if points.size() == 1:
				# Edge case (shouldn't happen due to check above),
				# but we handle it just in case.
				continue
			direction = (points[i + 1] - points[i]).normalized()
			distance = points[i].distance_to(points[i + 1])

		elif i == points.size() - 1:
			# Last point: use the segment from point[n-2] to point[n-1],
			# but only extend backward.
			direction = (points[i] - points[i - 1]).normalized()
			distance = points[i - 1].distance_to(points[i])

		else:
			# Interior point: use the segment from (i-1) to (i+1).
			direction = (points[i + 1] - points[i - 1]).normalized()
			distance = points[i - 1].distance_to(points[i + 1])

		# ---------------------------------------------------------------------
		# STEP 2: Center = this point, half-length = distance / 2 (or possibly
		#         just distance if it's the first or last point).
		# ---------------------------------------------------------------------
		var center: Vector2 = points[i]
		var half_width: float = width / 2.0
		var half_length: float = distance / 2.0

		# ---------------------------------------------------------------------
		# STEP 3: Compute perpendicular vector
		# ---------------------------------------------------------------------
		var perpendicular: Vector2 = Vector2(-direction.y, direction.x)

		# ---------------------------------------------------------------------
		# STEP 4: Build the rectangle corners
		# ---------------------------------------------------------------------
		var rect_points: PackedVector2Array = PackedVector2Array()

		if i == 0:
			# First point: do NOT extend behind the point
			# So we only go forward by half_length in 'direction'.
			rect_points.append(center + perpendicular * half_width)                           # top-left
			rect_points.append(center + perpendicular * half_width + direction * half_length) # top-right
			rect_points.append(center - perpendicular * half_width + direction * half_length) # bottom-right
			rect_points.append(center - perpendicular * half_width)                           # bottom-left

		elif i == points.size() - 1:
			# Last point: do NOT extend beyond the last point
			# So we only go backward by half_length in '-direction'.
			rect_points.append(center + perpendicular * half_width - direction * half_length) # top-left
			rect_points.append(center + perpendicular * half_width)                           # top-right
			rect_points.append(center - perpendicular * half_width)                           # bottom-right
			rect_points.append(center - perpendicular * half_width - direction * half_length) # bottom-left

		else:
			# Interior point: extend half_length in both directions
			rect_points.append(center + perpendicular * half_width - direction * half_length) # top-left
			rect_points.append(center + perpendicular * half_width + direction * half_length) # top-right
			rect_points.append(center - perpendicular * half_width + direction * half_length) # bottom-right
			rect_points.append(center - perpendicular * half_width - direction * half_length) # bottom-left

		temp_recs.append(rect_points)

	return temp_recs
